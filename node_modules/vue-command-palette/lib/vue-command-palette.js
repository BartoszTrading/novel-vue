import { ref as C, watch as ee, getCurrentScope as at, onScopeDispose as lt, unref as ie, reactive as de, computed as $, toRefs as ut, defineComponent as x, provide as ht, nextTick as se, onMounted as dt, openBlock as P, createElementBlock as H, normalizeClass as ft, createElementVNode as G, renderSlot as z, onBeforeUnmount as Se, createBlock as Le, Teleport as mt, createVNode as pt, Transition as gt, withCtx as ke, createCommentVNode as fe, withDirectives as Be, toDisplayString as _t, vShow as We, watchEffect as we, h as ce } from "vue";
var Ce;
const Ue = typeof window < "u", vt = (s) => typeof s == "string", oe = () => {
};
Ue && ((Ce = window == null ? void 0 : window.navigator) != null && Ce.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function me(s) {
  return typeof s == "function" ? s() : ie(s);
}
function yt(s, e) {
  function t(...n) {
    s(() => e.apply(this, n), { fn: e, thisArg: this, args: n });
  }
  return t;
}
function Et(s, e = {}) {
  let t, n;
  return (o) => {
    const i = me(s), c = me(e.maxWait);
    if (t && clearTimeout(t), i <= 0 || c !== void 0 && c <= 0)
      return n && (clearTimeout(n), n = null), o();
    c && !n && (n = setTimeout(() => {
      t && clearTimeout(t), n = null, o();
    }, c)), t = setTimeout(() => {
      n && clearTimeout(n), n = null, o();
    }, i);
  };
}
function It(s) {
  return s;
}
function St(s) {
  return at() ? (lt(s), !0) : !1;
}
function wt(s, e = 200, t = {}) {
  return yt(Et(e, t), s);
}
function ue(s, e = 200, t = {}) {
  if (e <= 0)
    return s;
  const n = C(s.value), r = wt(() => {
    n.value = s.value;
  }, e, t);
  return ee(s, () => r()), n;
}
function ze(s, e, t) {
  return ee(s, (n, r, o) => {
    n && e(n, r, o);
  }, t);
}
function Mt(s) {
  var e;
  const t = me(s);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const He = Ue ? window : void 0;
function ne(...s) {
  let e, t, n, r;
  if (vt(s[0]) ? ([t, n, r] = s, e = He) : [e, t, n, r] = s, !e)
    return oe;
  let o = oe;
  const i = ee(() => Mt(e), (a) => {
    o(), a && (a.addEventListener(t, n, r), o = () => {
      a.removeEventListener(t, n, r), o = oe;
    });
  }, { immediate: !0, flush: "post" }), c = () => {
    i(), o();
  };
  return St(c), c;
}
const $e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Te = "__vueuse_ssr_handlers__";
$e[Te] = $e[Te] || {};
const bt = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function xt(s = {}) {
  const {
    reactive: e = !1,
    target: t = He,
    aliasMap: n = bt,
    passive: r = !0,
    onEventFired: o = oe
  } = s, i = de(/* @__PURE__ */ new Set()), c = { toJSON() {
    return {};
  }, current: i }, a = e ? de(c) : c, u = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set();
  function d(f, g) {
    f in a && (e ? a[f] = g : a[f].value = g);
  }
  function p() {
    for (const f of h)
      d(f, !1);
  }
  function y(f, g) {
    var I, M;
    const S = (I = f.key) == null ? void 0 : I.toLowerCase(), B = [(M = f.code) == null ? void 0 : M.toLowerCase(), S].filter(Boolean);
    S && (g ? i.add(S) : i.delete(S));
    for (const O of B)
      h.add(O), d(O, g);
    S === "meta" && !g ? (u.forEach((O) => {
      i.delete(O), d(O, !1);
    }), u.clear()) : typeof f.getModifierState == "function" && f.getModifierState("Meta") && g && [...i, ...B].forEach((O) => u.add(O));
  }
  ne(t, "keydown", (f) => (y(f, !0), o(f)), { passive: r }), ne(t, "keyup", (f) => (y(f, !1), o(f)), { passive: r }), ne("blur", p, { passive: !0 }), ne("focus", p, { passive: !0 });
  const _ = new Proxy(a, {
    get(f, g, I) {
      if (typeof g != "string")
        return Reflect.get(f, g, I);
      if (g = g.toLowerCase(), g in n && (g = n[g]), !(g in a))
        if (/[+_-]/.test(g)) {
          const S = g.split(/[+_-]/g).map((k) => k.trim());
          a[g] = $(() => S.every((k) => ie(_[k])));
        } else
          a[g] = C(!1);
      const M = Reflect.get(f, g, I);
      return e ? ie(M) : M;
    }
  });
  return _;
}
var Ne;
(function(s) {
  s.UP = "UP", s.RIGHT = "RIGHT", s.DOWN = "DOWN", s.LEFT = "LEFT", s.NONE = "NONE";
})(Ne || (Ne = {}));
var At = Object.defineProperty, Fe = Object.getOwnPropertySymbols, Ot = Object.prototype.hasOwnProperty, Rt = Object.prototype.propertyIsEnumerable, Pe = (s, e, t) => e in s ? At(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, Lt = (s, e) => {
  for (var t in e || (e = {}))
    Ot.call(e, t) && Pe(s, t, e[t]);
  if (Fe)
    for (var t of Fe(e))
      Rt.call(e, t) && Pe(s, t, e[t]);
  return s;
};
const kt = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Lt({
  linear: It
}, kt);
function K(s) {
  return Array.isArray ? Array.isArray(s) : Je(s) === "[object Array]";
}
const Ct = 1 / 0;
function $t(s) {
  if (typeof s == "string")
    return s;
  let e = s + "";
  return e == "0" && 1 / s == -Ct ? "-0" : e;
}
function Tt(s) {
  return s == null ? "" : $t(s);
}
function F(s) {
  return typeof s == "string";
}
function Qe(s) {
  return typeof s == "number";
}
function Nt(s) {
  return s === !0 || s === !1 || Ft(s) && Je(s) == "[object Boolean]";
}
function Ye(s) {
  return typeof s == "object";
}
function Ft(s) {
  return Ye(s) && s !== null;
}
function L(s) {
  return s != null;
}
function he(s) {
  return !s.trim().length;
}
function Je(s) {
  return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
const Pt = "Incorrect 'index' type", Kt = (s) => `Invalid value for key ${s}`, Dt = (s) => `Pattern length exceeds max of ${s}.`, jt = (s) => `Missing ${s} property in key`, Gt = (s) => `Property 'weight' in key '${s}' must be a positive integer`, Ke = Object.prototype.hasOwnProperty;
class Vt {
  constructor(e) {
    this._keys = [], this._keyMap = {};
    let t = 0;
    e.forEach((n) => {
      let r = Xe(n);
      t += r.weight, this._keys.push(r), this._keyMap[r.id] = r, t += r.weight;
    }), this._keys.forEach((n) => {
      n.weight /= t;
    });
  }
  get(e) {
    return this._keyMap[e];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function Xe(s) {
  let e = null, t = null, n = null, r = 1, o = null;
  if (F(s) || K(s))
    n = s, e = De(s), t = pe(s);
  else {
    if (!Ke.call(s, "name"))
      throw new Error(jt("name"));
    const i = s.name;
    if (n = i, Ke.call(s, "weight") && (r = s.weight, r <= 0))
      throw new Error(Gt(i));
    e = De(i), t = pe(i), o = s.getFn;
  }
  return { path: e, id: t, weight: r, src: n, getFn: o };
}
function De(s) {
  return K(s) ? s : s.split(".");
}
function pe(s) {
  return K(s) ? s.join(".") : s;
}
function Bt(s, e) {
  let t = [], n = !1;
  const r = (o, i, c) => {
    if (L(o))
      if (!i[c])
        t.push(o);
      else {
        let a = i[c];
        const u = o[a];
        if (!L(u))
          return;
        if (c === i.length - 1 && (F(u) || Qe(u) || Nt(u)))
          t.push(Tt(u));
        else if (K(u)) {
          n = !0;
          for (let h = 0, d = u.length; h < d; h += 1)
            r(u[h], i, c + 1);
        } else
          i.length && r(u, i, c + 1);
      }
  };
  return r(s, F(e) ? e.split(".") : e, 0), n ? t : t[0];
}
const Wt = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: !1,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: !1,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
}, Ut = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: !1,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: !1,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: !0,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (s, e) => s.score === e.score ? s.idx < e.idx ? -1 : 1 : s.score < e.score ? -1 : 1
}, zt = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
}, Ht = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: !1,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: Bt,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: !1,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: !1,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var m = {
  ...Ut,
  ...Wt,
  ...zt,
  ...Ht
};
const Qt = /[^ ]+/g;
function Yt(s = 1, e = 3) {
  const t = /* @__PURE__ */ new Map(), n = Math.pow(10, e);
  return {
    get(r) {
      const o = r.match(Qt).length;
      if (t.has(o))
        return t.get(o);
      const i = 1 / Math.pow(o, 0.5 * s), c = parseFloat(Math.round(i * n) / n);
      return t.set(o, c), c;
    },
    clear() {
      t.clear();
    }
  };
}
class Me {
  constructor({
    getFn: e = m.getFn,
    fieldNormWeight: t = m.fieldNormWeight
  } = {}) {
    this.norm = Yt(t, 3), this.getFn = e, this.isCreated = !1, this.setIndexRecords();
  }
  setSources(e = []) {
    this.docs = e;
  }
  setIndexRecords(e = []) {
    this.records = e;
  }
  setKeys(e = []) {
    this.keys = e, this._keysMap = {}, e.forEach((t, n) => {
      this._keysMap[t.id] = n;
    });
  }
  create() {
    this.isCreated || !this.docs.length || (this.isCreated = !0, F(this.docs[0]) ? this.docs.forEach((e, t) => {
      this._addString(e, t);
    }) : this.docs.forEach((e, t) => {
      this._addObject(e, t);
    }), this.norm.clear());
  }
  // Adds a doc to the end of the index
  add(e) {
    const t = this.size();
    F(e) ? this._addString(e, t) : this._addObject(e, t);
  }
  // Removes the doc at the specified index of the index
  removeAt(e) {
    this.records.splice(e, 1);
    for (let t = e, n = this.size(); t < n; t += 1)
      this.records[t].i -= 1;
  }
  getValueForItemAtKeyId(e, t) {
    return e[this._keysMap[t]];
  }
  size() {
    return this.records.length;
  }
  _addString(e, t) {
    if (!L(e) || he(e))
      return;
    let n = {
      v: e,
      i: t,
      n: this.norm.get(e)
    };
    this.records.push(n);
  }
  _addObject(e, t) {
    let n = { i: t, $: {} };
    this.keys.forEach((r, o) => {
      let i = r.getFn ? r.getFn(e) : this.getFn(e, r.path);
      if (L(i)) {
        if (K(i)) {
          let c = [];
          const a = [{ nestedArrIndex: -1, value: i }];
          for (; a.length; ) {
            const { nestedArrIndex: u, value: h } = a.pop();
            if (L(h))
              if (F(h) && !he(h)) {
                let d = {
                  v: h,
                  i: u,
                  n: this.norm.get(h)
                };
                c.push(d);
              } else
                K(h) && h.forEach((d, p) => {
                  a.push({
                    nestedArrIndex: p,
                    value: d
                  });
                });
          }
          n.$[o] = c;
        } else if (F(i) && !he(i)) {
          let c = {
            v: i,
            n: this.norm.get(i)
          };
          n.$[o] = c;
        }
      }
    }), this.records.push(n);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function Ze(s, e, { getFn: t = m.getFn, fieldNormWeight: n = m.fieldNormWeight } = {}) {
  const r = new Me({ getFn: t, fieldNormWeight: n });
  return r.setKeys(s.map(Xe)), r.setSources(e), r.create(), r;
}
function Jt(s, { getFn: e = m.getFn, fieldNormWeight: t = m.fieldNormWeight } = {}) {
  const { keys: n, records: r } = s, o = new Me({ getFn: e, fieldNormWeight: t });
  return o.setKeys(n), o.setIndexRecords(r), o;
}
function re(s, {
  errors: e = 0,
  currentLocation: t = 0,
  expectedLocation: n = 0,
  distance: r = m.distance,
  ignoreLocation: o = m.ignoreLocation
} = {}) {
  const i = e / s.length;
  if (o)
    return i;
  const c = Math.abs(n - t);
  return r ? i + c / r : c ? 1 : i;
}
function Xt(s = [], e = m.minMatchCharLength) {
  let t = [], n = -1, r = -1, o = 0;
  for (let i = s.length; o < i; o += 1) {
    let c = s[o];
    c && n === -1 ? n = o : !c && n !== -1 && (r = o - 1, r - n + 1 >= e && t.push([n, r]), n = -1);
  }
  return s[o - 1] && o - n >= e && t.push([n, o - 1]), t;
}
const U = 32;
function Zt(s, e, t, {
  location: n = m.location,
  distance: r = m.distance,
  threshold: o = m.threshold,
  findAllMatches: i = m.findAllMatches,
  minMatchCharLength: c = m.minMatchCharLength,
  includeMatches: a = m.includeMatches,
  ignoreLocation: u = m.ignoreLocation
} = {}) {
  if (e.length > U)
    throw new Error(Dt(U));
  const h = e.length, d = s.length, p = Math.max(0, Math.min(n, d));
  let y = o, _ = p;
  const f = c > 1 || a, g = f ? Array(d) : [];
  let I;
  for (; (I = s.indexOf(e, _)) > -1; ) {
    let A = re(e, {
      currentLocation: I,
      expectedLocation: p,
      distance: r,
      ignoreLocation: u
    });
    if (y = Math.min(A, y), _ = I + h, f) {
      let R = 0;
      for (; R < h; )
        g[I + R] = 1, R += 1;
    }
  }
  _ = -1;
  let M = [], S = 1, k = h + d;
  const B = 1 << h - 1;
  for (let A = 0; A < h; A += 1) {
    let R = 0, T = k;
    for (; R < T; )
      re(e, {
        errors: A,
        currentLocation: p + T,
        expectedLocation: p,
        distance: r,
        ignoreLocation: u
      }) <= y ? R = T : k = T, T = Math.floor((k - R) / 2 + R);
    k = T;
    let X = Math.max(1, p - T + 1), D = i ? d : Math.min(p + T, d) + h, N = Array(D + 2);
    N[D + 1] = (1 << A) - 1;
    for (let b = D; b >= X; b -= 1) {
      let W = b - 1, q = t[s.charAt(W)];
      if (f && (g[W] = +!!q), N[b] = (N[b + 1] << 1 | 1) & q, A && (N[b] |= (M[b + 1] | M[b]) << 1 | 1 | M[b + 1]), N[b] & B && (S = re(e, {
        errors: A,
        currentLocation: W,
        expectedLocation: p,
        distance: r,
        ignoreLocation: u
      }), S <= y)) {
        if (y = S, _ = W, _ <= p)
          break;
        X = Math.max(1, 2 * p - _);
      }
    }
    if (re(e, {
      errors: A + 1,
      currentLocation: p,
      expectedLocation: p,
      distance: r,
      ignoreLocation: u
    }) > y)
      break;
    M = N;
  }
  const O = {
    isMatch: _ >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, S)
  };
  if (f) {
    const A = Xt(g, c);
    A.length ? a && (O.indices = A) : O.isMatch = !1;
  }
  return O;
}
function qt(s) {
  let e = {};
  for (let t = 0, n = s.length; t < n; t += 1) {
    const r = s.charAt(t);
    e[r] = (e[r] || 0) | 1 << n - t - 1;
  }
  return e;
}
class qe {
  constructor(e, {
    location: t = m.location,
    threshold: n = m.threshold,
    distance: r = m.distance,
    includeMatches: o = m.includeMatches,
    findAllMatches: i = m.findAllMatches,
    minMatchCharLength: c = m.minMatchCharLength,
    isCaseSensitive: a = m.isCaseSensitive,
    ignoreLocation: u = m.ignoreLocation
  } = {}) {
    if (this.options = {
      location: t,
      threshold: n,
      distance: r,
      includeMatches: o,
      findAllMatches: i,
      minMatchCharLength: c,
      isCaseSensitive: a,
      ignoreLocation: u
    }, this.pattern = a ? e : e.toLowerCase(), this.chunks = [], !this.pattern.length)
      return;
    const h = (p, y) => {
      this.chunks.push({
        pattern: p,
        alphabet: qt(p),
        startIndex: y
      });
    }, d = this.pattern.length;
    if (d > U) {
      let p = 0;
      const y = d % U, _ = d - y;
      for (; p < _; )
        h(this.pattern.substr(p, U), p), p += U;
      if (y) {
        const f = d - U;
        h(this.pattern.substr(f), f);
      }
    } else
      h(this.pattern, 0);
  }
  searchIn(e) {
    const { isCaseSensitive: t, includeMatches: n } = this.options;
    if (t || (e = e.toLowerCase()), this.pattern === e) {
      let _ = {
        isMatch: !0,
        score: 0
      };
      return n && (_.indices = [[0, e.length - 1]]), _;
    }
    const {
      location: r,
      distance: o,
      threshold: i,
      findAllMatches: c,
      minMatchCharLength: a,
      ignoreLocation: u
    } = this.options;
    let h = [], d = 0, p = !1;
    this.chunks.forEach(({ pattern: _, alphabet: f, startIndex: g }) => {
      const { isMatch: I, score: M, indices: S } = Zt(e, _, f, {
        location: r + g,
        distance: o,
        threshold: i,
        findAllMatches: c,
        minMatchCharLength: a,
        includeMatches: n,
        ignoreLocation: u
      });
      I && (p = !0), d += M, I && S && (h = [...h, ...S]);
    });
    let y = {
      isMatch: p,
      score: p ? d / this.chunks.length : 1
    };
    return p && n && (y.indices = h), y;
  }
}
class V {
  constructor(e) {
    this.pattern = e;
  }
  static isMultiMatch(e) {
    return je(e, this.multiRegex);
  }
  static isSingleMatch(e) {
    return je(e, this.singleRegex);
  }
  search() {
  }
}
function je(s, e) {
  const t = s.match(e);
  return t ? t[1] : null;
}
class es extends V {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(e) {
    const t = e === this.pattern;
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class ts extends V {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(e) {
    const n = e.indexOf(this.pattern) === -1;
    return {
      isMatch: n,
      score: n ? 0 : 1,
      indices: [0, e.length - 1]
    };
  }
}
class ss extends V {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(e) {
    const t = e.startsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class ns extends V {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(e) {
    const t = !e.startsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, e.length - 1]
    };
  }
}
class rs extends V {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(e) {
    const t = e.endsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [e.length - this.pattern.length, e.length - 1]
    };
  }
}
class os extends V {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(e) {
    const t = !e.endsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, e.length - 1]
    };
  }
}
class et extends V {
  constructor(e, {
    location: t = m.location,
    threshold: n = m.threshold,
    distance: r = m.distance,
    includeMatches: o = m.includeMatches,
    findAllMatches: i = m.findAllMatches,
    minMatchCharLength: c = m.minMatchCharLength,
    isCaseSensitive: a = m.isCaseSensitive,
    ignoreLocation: u = m.ignoreLocation
  } = {}) {
    super(e), this._bitapSearch = new qe(e, {
      location: t,
      threshold: n,
      distance: r,
      includeMatches: o,
      findAllMatches: i,
      minMatchCharLength: c,
      isCaseSensitive: a,
      ignoreLocation: u
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(e) {
    return this._bitapSearch.searchIn(e);
  }
}
class tt extends V {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(e) {
    let t = 0, n;
    const r = [], o = this.pattern.length;
    for (; (n = e.indexOf(this.pattern, t)) > -1; )
      t = n + o, r.push([n, t - 1]);
    const i = !!r.length;
    return {
      isMatch: i,
      score: i ? 0 : 1,
      indices: r
    };
  }
}
const ge = [
  es,
  tt,
  ss,
  ns,
  os,
  rs,
  ts,
  et
], Ge = ge.length, is = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, cs = "|";
function as(s, e = {}) {
  return s.split(cs).map((t) => {
    let n = t.trim().split(is).filter((o) => o && !!o.trim()), r = [];
    for (let o = 0, i = n.length; o < i; o += 1) {
      const c = n[o];
      let a = !1, u = -1;
      for (; !a && ++u < Ge; ) {
        const h = ge[u];
        let d = h.isMultiMatch(c);
        d && (r.push(new h(d, e)), a = !0);
      }
      if (!a)
        for (u = -1; ++u < Ge; ) {
          const h = ge[u];
          let d = h.isSingleMatch(c);
          if (d) {
            r.push(new h(d, e));
            break;
          }
        }
    }
    return r;
  });
}
const ls = /* @__PURE__ */ new Set([et.type, tt.type]);
class us {
  constructor(e, {
    isCaseSensitive: t = m.isCaseSensitive,
    includeMatches: n = m.includeMatches,
    minMatchCharLength: r = m.minMatchCharLength,
    ignoreLocation: o = m.ignoreLocation,
    findAllMatches: i = m.findAllMatches,
    location: c = m.location,
    threshold: a = m.threshold,
    distance: u = m.distance
  } = {}) {
    this.query = null, this.options = {
      isCaseSensitive: t,
      includeMatches: n,
      minMatchCharLength: r,
      findAllMatches: i,
      ignoreLocation: o,
      location: c,
      threshold: a,
      distance: u
    }, this.pattern = t ? e : e.toLowerCase(), this.query = as(this.pattern, this.options);
  }
  static condition(e, t) {
    return t.useExtendedSearch;
  }
  searchIn(e) {
    const t = this.query;
    if (!t)
      return {
        isMatch: !1,
        score: 1
      };
    const { includeMatches: n, isCaseSensitive: r } = this.options;
    e = r ? e : e.toLowerCase();
    let o = 0, i = [], c = 0;
    for (let a = 0, u = t.length; a < u; a += 1) {
      const h = t[a];
      i.length = 0, o = 0;
      for (let d = 0, p = h.length; d < p; d += 1) {
        const y = h[d], { isMatch: _, indices: f, score: g } = y.search(e);
        if (_) {
          if (o += 1, c += g, n) {
            const I = y.constructor.type;
            ls.has(I) ? i = [...i, ...f] : i.push(f);
          }
        } else {
          c = 0, o = 0, i.length = 0;
          break;
        }
      }
      if (o) {
        let d = {
          isMatch: !0,
          score: c / o
        };
        return n && (d.indices = i), d;
      }
    }
    return {
      isMatch: !1,
      score: 1
    };
  }
}
const _e = [];
function hs(...s) {
  _e.push(...s);
}
function ve(s, e) {
  for (let t = 0, n = _e.length; t < n; t += 1) {
    let r = _e[t];
    if (r.condition(s, e))
      return new r(s, e);
  }
  return new qe(s, e);
}
const ae = {
  AND: "$and",
  OR: "$or"
}, ye = {
  PATH: "$path",
  PATTERN: "$val"
}, Ee = (s) => !!(s[ae.AND] || s[ae.OR]), ds = (s) => !!s[ye.PATH], fs = (s) => !K(s) && Ye(s) && !Ee(s), Ve = (s) => ({
  [ae.AND]: Object.keys(s).map((e) => ({
    [e]: s[e]
  }))
});
function st(s, e, { auto: t = !0 } = {}) {
  const n = (r) => {
    let o = Object.keys(r);
    const i = ds(r);
    if (!i && o.length > 1 && !Ee(r))
      return n(Ve(r));
    if (fs(r)) {
      const a = i ? r[ye.PATH] : o[0], u = i ? r[ye.PATTERN] : r[a];
      if (!F(u))
        throw new Error(Kt(a));
      const h = {
        keyId: pe(a),
        pattern: u
      };
      return t && (h.searcher = ve(u, e)), h;
    }
    let c = {
      children: [],
      operator: o[0]
    };
    return o.forEach((a) => {
      const u = r[a];
      K(u) && u.forEach((h) => {
        c.children.push(n(h));
      });
    }), c;
  };
  return Ee(s) || (s = Ve(s)), n(s);
}
function ms(s, { ignoreFieldNorm: e = m.ignoreFieldNorm }) {
  s.forEach((t) => {
    let n = 1;
    t.matches.forEach(({ key: r, norm: o, score: i }) => {
      const c = r ? r.weight : null;
      n *= Math.pow(
        i === 0 && c ? Number.EPSILON : i,
        (c || 1) * (e ? 1 : o)
      );
    }), t.score = n;
  });
}
function ps(s, e) {
  const t = s.matches;
  e.matches = [], L(t) && t.forEach((n) => {
    if (!L(n.indices) || !n.indices.length)
      return;
    const { indices: r, value: o } = n;
    let i = {
      indices: r,
      value: o
    };
    n.key && (i.key = n.key.src), n.idx > -1 && (i.refIndex = n.idx), e.matches.push(i);
  });
}
function gs(s, e) {
  e.score = s.score;
}
function _s(s, e, {
  includeMatches: t = m.includeMatches,
  includeScore: n = m.includeScore
} = {}) {
  const r = [];
  return t && r.push(ps), n && r.push(gs), s.map((o) => {
    const { idx: i } = o, c = {
      item: e[i],
      refIndex: i
    };
    return r.length && r.forEach((a) => {
      a(o, c);
    }), c;
  });
}
class Q {
  constructor(e, t = {}, n) {
    this.options = { ...m, ...t }, this.options.useExtendedSearch, this._keyStore = new Vt(this.options.keys), this.setCollection(e, n);
  }
  setCollection(e, t) {
    if (this._docs = e, t && !(t instanceof Me))
      throw new Error(Pt);
    this._myIndex = t || Ze(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(e) {
    L(e) && (this._docs.push(e), this._myIndex.add(e));
  }
  remove(e = () => !1) {
    const t = [];
    for (let n = 0, r = this._docs.length; n < r; n += 1) {
      const o = this._docs[n];
      e(o, n) && (this.removeAt(n), n -= 1, r -= 1, t.push(o));
    }
    return t;
  }
  removeAt(e) {
    this._docs.splice(e, 1), this._myIndex.removeAt(e);
  }
  getIndex() {
    return this._myIndex;
  }
  search(e, { limit: t = -1 } = {}) {
    const {
      includeMatches: n,
      includeScore: r,
      shouldSort: o,
      sortFn: i,
      ignoreFieldNorm: c
    } = this.options;
    let a = F(e) ? F(this._docs[0]) ? this._searchStringList(e) : this._searchObjectList(e) : this._searchLogical(e);
    return ms(a, { ignoreFieldNorm: c }), o && a.sort(i), Qe(t) && t > -1 && (a = a.slice(0, t)), _s(a, this._docs, {
      includeMatches: n,
      includeScore: r
    });
  }
  _searchStringList(e) {
    const t = ve(e, this.options), { records: n } = this._myIndex, r = [];
    return n.forEach(({ v: o, i, n: c }) => {
      if (!L(o))
        return;
      const { isMatch: a, score: u, indices: h } = t.searchIn(o);
      a && r.push({
        item: o,
        idx: i,
        matches: [{ score: u, value: o, norm: c, indices: h }]
      });
    }), r;
  }
  _searchLogical(e) {
    const t = st(e, this.options), n = (c, a, u) => {
      if (!c.children) {
        const { keyId: d, searcher: p } = c, y = this._findMatches({
          key: this._keyStore.get(d),
          value: this._myIndex.getValueForItemAtKeyId(a, d),
          searcher: p
        });
        return y && y.length ? [
          {
            idx: u,
            item: a,
            matches: y
          }
        ] : [];
      }
      const h = [];
      for (let d = 0, p = c.children.length; d < p; d += 1) {
        const y = c.children[d], _ = n(y, a, u);
        if (_.length)
          h.push(..._);
        else if (c.operator === ae.AND)
          return [];
      }
      return h;
    }, r = this._myIndex.records, o = {}, i = [];
    return r.forEach(({ $: c, i: a }) => {
      if (L(c)) {
        let u = n(t, c, a);
        u.length && (o[a] || (o[a] = { idx: a, item: c, matches: [] }, i.push(o[a])), u.forEach(({ matches: h }) => {
          o[a].matches.push(...h);
        }));
      }
    }), i;
  }
  _searchObjectList(e) {
    const t = ve(e, this.options), { keys: n, records: r } = this._myIndex, o = [];
    return r.forEach(({ $: i, i: c }) => {
      if (!L(i))
        return;
      let a = [];
      n.forEach((u, h) => {
        a.push(
          ...this._findMatches({
            key: u,
            value: i[h],
            searcher: t
          })
        );
      }), a.length && o.push({
        idx: c,
        item: i,
        matches: a
      });
    }), o;
  }
  _findMatches({ key: e, value: t, searcher: n }) {
    if (!L(t))
      return [];
    let r = [];
    if (K(t))
      t.forEach(({ v: o, i, n: c }) => {
        if (!L(o))
          return;
        const { isMatch: a, score: u, indices: h } = n.searchIn(o);
        a && r.push({
          score: u,
          key: e,
          value: o,
          idx: i,
          norm: c,
          indices: h
        });
      });
    else {
      const { v: o, n: i } = t, { isMatch: c, score: a, indices: u } = n.searchIn(o);
      c && r.push({ score: a, key: e, value: o, norm: i, indices: u });
    }
    return r;
  }
}
Q.version = "6.6.2";
Q.createIndex = Ze;
Q.parseIndex = Jt;
Q.config = m;
Q.parseQuery = st;
hs(us);
const Y = de({
  selectedNode: "",
  selectedGroup: "",
  shouldRerender: !1,
  /** Value of the search query. */
  search: "",
  filtered: {
    /** The count of all visible items. */
    count: 0,
    /** Map from visible item id. */
    items: /* @__PURE__ */ new Map(),
    /** Set of groups with at least one visible item. */
    groups: /* @__PURE__ */ new Set()
  }
}), J = () => ({
  isSearching: $(() => Y.search !== ""),
  resetStore: () => {
    Y.search = "", Y.filtered.count = 0, Y.filtered.items = /* @__PURE__ */ new Map(), Y.filtered.groups = /* @__PURE__ */ new Set();
  },
  ...ut(Y)
});
function vs(s) {
  return { all: s = s || /* @__PURE__ */ new Map(), on: function(e, t) {
    var n = s.get(e);
    n ? n.push(t) : s.set(e, [t]);
  }, off: function(e, t) {
    var n = s.get(e);
    n && (t ? n.splice(n.indexOf(t) >>> 0, 1) : s.set(e, []));
  }, emit: function(e, t) {
    var n = s.get(e);
    n && n.slice().map(function(r) {
      r(t);
    }), (n = s.get("*")) && n.slice().map(function(r) {
      r(e, t);
    });
  } };
}
const ys = vs(), le = () => ({
  emitter: ys
});
function Es(s, e) {
  let t = s.nextElementSibling;
  for (; t; ) {
    if (t.matches(e))
      return t;
    t = t.nextElementSibling;
  }
}
function Is(s, e) {
  let t = s.previousElementSibling;
  for (; t; ) {
    if (t.matches(e))
      return t;
    t = t.previousElementSibling;
  }
}
const Ss = ["command-theme"], ws = { "command-root": "" }, Ms = x({
  name: "CommandRoot"
}), Ie = /* @__PURE__ */ x({
  ...Ms,
  props: {
    theme: {
      type: String,
      default: "default"
    },
    fuseOptions: {
      type: Object,
      default: () => ({
        threshold: 0.2,
        keys: ["label"]
      })
    }
  },
  emits: ["select-item"],
  setup(s, { emit: e }) {
    const t = s, n = '[command-item=""]', r = "command-item-key", o = '[command-group=""]', i = "command-group-key", c = '[command-group-heading=""]', a = `${n}:not([aria-disabled="true"])`, u = `${n}[aria-selected="true"]`, h = "command-item-select", d = "data-value";
    ht("theme", t.theme || "default");
    const { selectedNode: p, search: y, filtered: _, shouldRerender: f } = J(), { emitter: g } = le(), I = C(), M = ue(C(/* @__PURE__ */ new Map()), 333), S = ue(C(/* @__PURE__ */ new Set()), 333), k = ue(C(/* @__PURE__ */ new Map())), B = $(() => {
      const l = [];
      for (const [E, v] of M.value.entries())
        l.push({
          key: E,
          label: v
        });
      return l;
    }), O = $(() => {
      const l = Q.createIndex(
        t.fuseOptions.keys,
        B.value
      );
      return new Q(B.value, t.fuseOptions, l);
    }), A = () => {
      var E, v, w;
      const l = R();
      l && (((E = l.parentElement) == null ? void 0 : E.firstElementChild) === l && ((w = (v = l.closest(o)) == null ? void 0 : v.querySelector(c)) == null || w.scrollIntoView({ block: "nearest" })), l.scrollIntoView({ block: "nearest" }));
    }, R = () => {
      var l;
      return (l = I.value) == null ? void 0 : l.querySelector(u);
    }, T = () => {
      var E;
      const l = (E = I.value) == null ? void 0 : E.querySelectorAll(
        o
      );
      return l ? Array.from(l) : [];
    }, X = (l = I.value) => {
      const E = l == null ? void 0 : l.querySelectorAll(
        n
      );
      return E ? Array.from(E) : [];
    }, D = (l = I.value) => {
      const E = l == null ? void 0 : l.querySelectorAll(
        a
      );
      return E ? Array.from(E) : [];
    }, N = () => {
      const [l] = D();
      l && l.getAttribute(r) && (p.value = l.getAttribute(r) || "");
    }, Z = (l) => {
      const v = D()[l];
      v && (p.value = v.getAttribute(r) || "");
    }, b = (l) => {
      const E = R(), v = D(), w = v.findIndex((te) => te === E), j = v[w + l];
      j ? p.value = j.getAttribute(r) || "" : l > 0 ? Z(0) : Z(v.length - 1);
    }, W = (l) => {
      const E = R();
      let v = E == null ? void 0 : E.closest(o), w = null;
      for (; v && !w; )
        v = l > 0 ? Es(v, o) : Is(v, o), w = v == null ? void 0 : v.querySelector(a);
      w ? p.value = w.getAttribute(r) || "" : b(l);
    }, q = () => Z(0), be = () => Z(D().length - 1), xe = (l) => {
      l.preventDefault(), l.metaKey ? be() : l.altKey ? W(1) : b(1);
    }, Ae = (l) => {
      l.preventDefault(), l.metaKey ? q() : l.altKey ? W(-1) : b(-1);
    }, rt = (l) => {
      switch (l.key) {
        case "n":
        case "j": {
          l.ctrlKey && xe(l);
          break;
        }
        case "ArrowDown": {
          xe(l);
          break;
        }
        case "p":
        case "k": {
          l.ctrlKey && Ae(l);
          break;
        }
        case "ArrowUp": {
          Ae(l);
          break;
        }
        case "Home": {
          q();
          break;
        }
        case "End": {
          be();
          break;
        }
        case "Enter": {
          const E = R();
          if (E) {
            const v = new Event(h);
            E.dispatchEvent(v);
          }
        }
      }
    }, Oe = () => {
      if (!y.value) {
        _.value.count = S.value.size;
        return;
      }
      _.value.groups = /* @__PURE__ */ new Set();
      const l = /* @__PURE__ */ new Map(), E = O.value.search(y.value).map((v) => v.item);
      for (const { key: v, label: w } of E)
        l.set(v, w);
      for (const [v, w] of k.value)
        for (const j of w)
          l.get(j) && _.value.groups.add(v);
      _.value.count = l.size, _.value.items = l;
    }, Re = () => {
      const l = T(), E = X();
      for (const v of E) {
        const w = v.getAttribute(r) || "", j = v.getAttribute(d) || "";
        S.value.add(w), M.value.set(w, j), _.value.count = M.value.size;
      }
      for (const v of l) {
        const w = X(v), j = v.getAttribute(i) || "", te = new Set("");
        for (const it of w) {
          const ct = it.getAttribute(r) || "";
          te.add(ct);
        }
        k.value.set(j, te);
      }
    };
    ee(
      () => p.value,
      (l) => {
        l && se(A);
      },
      { deep: !0 }
    ), ee(
      () => y.value,
      () => {
        f.value || (Oe(), se(N));
      }
    ), g.on("selectItem", (l) => {
      e("select-item", l);
    });
    const ot = (l) => {
      l && (f.value = l, Re(), se(() => {
        Oe(), N(), f.value = !1;
      }));
    };
    return g.on("rerenderList", ot), dt(() => {
      Re(), se(N);
    }), (l, E) => (P(), H("div", {
      class: ft(s.theme),
      onKeydown: rt,
      ref_key: "commandRef",
      ref: I,
      "command-theme": s.theme
    }, [
      G("div", ws, [
        z(l.$slots, "default")
      ])
    ], 42, Ss));
  }
}), bs = { "command-dialog": "" }, xs = { "command-dialog-mask": "" }, As = { "command-dialog-wrapper": "" }, Os = { "command-dialog-header": "" }, Rs = { "command-dialog-body": "" }, Ls = {
  key: 0,
  "command-dialog-footer": ""
}, ks = x({
  name: "Command.Dialog"
}), Cs = /* @__PURE__ */ x({
  ...ks,
  props: {
    visible: { type: Boolean },
    theme: {}
  },
  emits: ["select-item"],
  setup(s, { emit: e }) {
    const t = s, { resetStore: n } = J(), { emitter: r } = le(), o = C();
    return r.on("selectItem", (i) => {
      e("select-item", i);
    }), ze(() => t.visible, n), Se(n), (i, c) => (P(), Le(mt, {
      to: "body",
      ref_key: "dialogRef",
      ref: o
    }, [
      pt(gt, {
        name: "command-dialog",
        appear: ""
      }, {
        default: ke(() => [
          i.visible ? (P(), Le(Ie, {
            key: 0,
            theme: i.theme
          }, {
            default: ke(() => [
              G("div", bs, [
                G("div", xs, [
                  G("div", As, [
                    G("div", Os, [
                      z(i.$slots, "header")
                    ]),
                    G("div", Rs, [
                      z(i.$slots, "body")
                    ]),
                    i.$slots.footer ? (P(), H("div", Ls, [
                      z(i.$slots, "footer")
                    ])) : fe("", !0)
                  ])
                ])
              ])
            ]),
            _: 3
          }, 8, ["theme"])) : fe("", !0)
        ]),
        _: 3
      })
    ], 512));
  }
});
let nt = (s = 21) => crypto.getRandomValues(new Uint8Array(s)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += "-" : e += "_", e), "");
const $s = ["command-group-key", "data-value"], Ts = {
  key: 0,
  "command-group-heading": ""
}, Ns = {
  "command-group-items": "",
  role: "group"
}, Fs = x({
  name: "Command.Group"
}), Ps = /* @__PURE__ */ x({
  ...Fs,
  props: {
    heading: {}
  },
  setup(s) {
    const e = $(() => `command-group-${nt()}`), { filtered: t, isSearching: n } = J(), r = $(
      () => n.value ? t.value.groups.has(e.value) : !0
    );
    return (o, i) => Be((P(), H("div", {
      "command-group": "",
      role: "presentation",
      key: e.value,
      "command-group-key": e.value,
      "data-value": o.heading
    }, [
      o.heading ? (P(), H("div", Ts, _t(o.heading), 1)) : fe("", !0),
      G("div", Ns, [
        z(o.$slots, "default")
      ])
    ], 8, $s)), [
      [We, r.value]
    ]);
  }
}), Ks = ["placeholder", "value"], Ds = x({
  name: "Command.Input"
}), js = /* @__PURE__ */ x({
  ...Ds,
  props: {
    placeholder: {},
    value: {}
  },
  emits: ["input", "update:value"],
  setup(s, { emit: e }) {
    const t = C(null), { search: n } = J(), r = $(() => n.value), o = (i) => {
      const c = i, a = i.target;
      n.value = a == null ? void 0 : a.value, e("input", c), e("update:value", n.value);
    };
    return we(() => {
      var i;
      (i = t.value) == null || i.focus();
    }), (i, c) => (P(), H("input", {
      ref_key: "inputRef",
      ref: t,
      "command-input": "",
      "auto-focus": "",
      "auto-complete": "off",
      "auto-correct": "off",
      "spell-check": !1,
      "aria-autocomplete": "list",
      role: "combobox",
      "aria-expanded": !0,
      placeholder: i.placeholder,
      value: r.value,
      onInput: o
    }, null, 40, Ks));
  }
}), Gs = ["aria-selected", "aria-disabled", "command-item-key"], Vs = x({
  name: "Command.Item"
}), Bs = /* @__PURE__ */ x({
  ...Vs,
  props: {
    shortcut: {},
    perform: { type: Function }
  },
  emits: ["select"],
  setup(s, { emit: e }) {
    const t = s, n = "command-item-select", r = "data-value", { current: o } = xt(), { selectedNode: i, filtered: c, isSearching: a } = J(), { emitter: u } = le(), h = C(), d = $(() => `command-item-${nt()}`), p = $(() => {
      const f = c.value.items.get(d.value);
      return a.value ? f !== void 0 : !0;
    }), y = $(() => Array.from(o)), _ = () => {
      var g;
      const f = {
        key: d.value,
        value: ((g = h.value) == null ? void 0 : g.getAttribute(r)) || ""
      };
      e("select", f), u.emit("selectItem", f);
    };
    return ze(y, (f) => {
      t.shortcut && t.shortcut.length > 0 && t.shortcut.every((I) => o.has(I.toLowerCase())) && t.perform && t.perform();
    }), we(() => {
      var f;
      (f = h.value) == null || f.addEventListener(n, _);
    }), Se(() => {
      var f;
      (f = h.value) == null || f.removeEventListener(n, _);
    }), (f, g) => Be((P(), H("div", {
      ref_key: "itemRef",
      ref: h,
      "command-item": "",
      role: "option",
      "aria-selected": ie(i) === d.value,
      "aria-disabled": !p.value,
      key: d.value,
      "command-item-key": d.value,
      onClick: _
    }, [
      z(f.$slots, "default")
    ], 8, Gs)), [
      [We, p.value]
    ]);
  }
}), Ws = x({
  name: "Command.List"
}), Us = /* @__PURE__ */ x({
  ...Ws,
  setup(s) {
    const { emitter: e } = le(), t = C(), n = C();
    let r = null, o;
    return we(() => {
      o = n.value;
      const i = t.value;
      let c;
      if (o && i)
        return r = new ResizeObserver((a) => {
          c = requestAnimationFrame(() => {
            const u = o == null ? void 0 : o.offsetHeight;
            i == null || i.style.setProperty(
              "--command-list-height",
              `${u == null ? void 0 : u.toFixed(1)}px`
            ), e.emit("rerenderList", !0);
          });
        }), r.observe(o), () => {
          cancelAnimationFrame(c), r == null || r.unobserve(o);
        };
    }), Se(() => {
      r !== null && o && r.unobserve(o);
    }), (i, c) => (P(), H("div", {
      "command-list": "",
      role: "listbox",
      "aria-label": "Suggestions",
      ref_key: "listRef",
      ref: t
    }, [
      G("div", {
        "command-list-sizer": "",
        ref_key: "heightRef",
        ref: n
      }, [
        z(i.$slots, "default")
      ], 512)
    ], 512));
  }
}), zs = x({
  name: "Command.Empty",
  setup(s, { attrs: e, slots: t }) {
    const { filtered: n } = J(), r = $(() => n.value.count === 0);
    return () => r.value ? ce(
      "div",
      {
        "command-empty": "",
        role: "presentation",
        ...e
      },
      t
    ) : ce("div", {
      "command-empty": "hidden",
      role: "presentation",
      style: {
        display: "none"
      },
      ...e
    });
  }
}), Hs = x({
  name: "Command.Loading",
  setup(s, { attrs: e, slots: t }) {
    return () => ce(
      "div",
      {
        "command-loading": "",
        role: "progressbar",
        ...e
      },
      t
    );
  }
}), Qs = x({
  name: "Command.Separator",
  setup(s, { attrs: e, slots: t }) {
    return () => ce("div", {
      "command-separator": "",
      role: "separator",
      ...e
    });
  }
}), Js = Object.assign(Ie, {
  Root: Ie,
  Dialog: Cs,
  Empty: zs,
  Group: Ps,
  Input: js,
  Item: Bs,
  List: Us,
  Loading: Hs,
  Separator: Qs
});
export {
  Js as Command,
  J as useCommandState
};
